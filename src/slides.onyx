use package core

Color :: struct {
    r, g, b: f32;
    a: f32 = 1;
}

Slideshow :: struct {
    // A basic arena that should store everything related to slides.
    // This makes it easy to free everything at once.
    arena : alloc.arena.ArenaState;

    title  : str;
    slides : [..] Slide;

    current_slide : i32;
}

Slide :: struct {
    background: Color;

    items : [] ^Slide_Item;
}

Slide_Item :: struct #union {
    Kind :: enum {
        Undefined;
        Text;
    }

    use base: Slide_Item_Base;
    text: Slide_Item_Text;
}

Slide_Item_Base :: struct {
    kind : Slide_Item.Kind;
}

Slide_Item_Text :: struct {
    use base : Slide_Item_Base;

    color : Color;

    font_name : str;
    font_size : u32;
    font_attr : FontAttributes;

    FontAttributes :: enum #flags { Bold; Italic; Underline; }

    Justify :: enum { Left; Center; Right; }

    text    : str;
    y_pos   : f32; // Between 0 and 1
    justify : Justify;
}



slideshow_make :: (allocator := context.allocator) -> Slideshow {
    slideshow: Slideshow;
    slideshow_init(^slideshow, allocator);
    return slideshow;
}

slideshow_init :: (use s: ^Slideshow, allocator := context.allocator) {
    title = "Untitled Slideshow";
    current_slide = 0;

    arena = alloc.arena.make(allocator, arena_size = 16 * 1024);
    array.init(^slides, 4);
}

slideshow_reset :: (use s: ^Slideshow) {
    alloc.arena.free(^arena);
    array.free(^slides);

    slideshow_init(s);
}

slideshow_get_current_slide :: (use s: ^Slideshow) -> ^Slide {
    current_slide = math.clamp(current_slide, 0, slides.count - 1); 

    return ^slides[current_slide];
}

slideshow_advance_slide :: (use s: ^Slideshow, count := 1) {
    current_slide += count;
    current_slide = math.clamp(current_slide, 0, slides.count - 1); 
}

slideshow_insert_slide :: (use s: ^Slideshow, at := -1) -> ^Slide {
    // @Robustness: not checking the return values on these calls

    if at > 0 {
        array.insert_empty(^slides, at);
        return ^slides[at];
    }

    array.ensure_capacity(^slides, slides.count + 1);
    defer slides.count += 1;
    return ^slides[slides.count];
}

slideshow_make_item :: (use s: ^Slideshow) -> ^Slide_Item {
    allocator := alloc.arena.make_allocator(^arena);
    return new(Slide_Item, allocator = allocator);
}

slide_init :: (use slide: ^Slide, background_color := Color.{0, 0, 0, 1}, item_count := 4) {
    background = background_color;

    items = memory.make_slice(#type ^Slide_Item, item_count);
    memory.set(items.data, 0, items.count * sizeof ^Slide_Item);
}

slide_render :: (use slide: ^Slide) {
    // I would like to alias Canvas to C here, but right now
    // this does not work:
    //
    //     C :: Canvas
    //
    Canvas.clear(canvas, background.r, background.g, background.b, background.a);

    for item: items do if item != null do slide_item_render(item, slide);
}

slide_item_render :: (use slide_item: ^Slide_Item, slide: ^Slide) {
    use Canvas
    use Slide_Item.Kind

    switch kind {
        case Text {
            set_font(canvas, text.font_name);
            draw_centered_text(text.text, text.y_pos);
        }
    }
}
