use package core
use package event as event

// @Cleanup: Move this elsewhere
draw_centered_text :: (text: str, y_baseline: f32) {
    use Canvas

    width, height := cast(f32) get_width(canvas), cast(f32) get_height(canvas);

    font_metrics: TextMetrics;
    measure_text(canvas, text, ^font_metrics);

    x := (width - font_metrics.width) / 2;

    fill_text(canvas, text, x, y_baseline * height);
}

// This is an integer, not a boolean, because I was noticing an issue
// where the slide would redraw, but the screen would still be blank
// because the window was still resizing. Having it do multiple redraws
// when needed prevents this issue.
redraw := 0

poll_events :: () {
    use event.DomEventKind

    ev: event.Event;
    while event.poll(^ev) do switch ev.kind {
        case Resize {
            printf("New window size: %i, %i\n", ev.resize.width, ev.resize.height);
            redraw = 2;

            use Canvas
            set_size(canvas, ev.resize.width, ev.resize.height);
        }

        case MouseDown {
            printf("Mouse down: %i, %i\n", ev.mouse.pos_x, ev.mouse.pos_y);

            use event.MouseButton
            switch ev.mouse.button {
                case Right    do slideshow_advance_slide(^the_slideshow, -1);
                case #default do slideshow_advance_slide(^the_slideshow, 1);
            }

            redraw = 2;
        }
    }
}

loop :: () -> void #export "loop" {
    poll_events();

    if redraw > 0 {
        current_slide := slideshow_get_current_slide(^the_slideshow);
        slide_render(current_slide);

        redraw -= 1;
    }
}

the_slideshow : Slideshow;

create_dummy_show :: () {
    the_slideshow = slideshow_make();
    
    { // Slide 1
        slide := slideshow_insert_slide(^the_slideshow);
        slide_init(slide, background_color = Color.{ 0.1, 0.1, 0.2 }, item_count = 2);
        
        slide.items[0] = slideshow_make_item(^the_slideshow);
        slide.items[0].kind = Slide_Item.Kind.Text;
        slide.items[0].text.text = "Hello, World!";
        slide.items[0].text.y_pos = .5;
        slide.items[0].text.font_name = "bold 72px Arail";

        slide.items[1] = slideshow_make_item(^the_slideshow);
        slide.items[1].kind = Slide_Item.Kind.Text;
        slide.items[1].text.text = "Another, smaller, line of text below the first!";
        slide.items[1].text.y_pos = .6;
        slide.items[1].text.font_name = "italic 36px Arail";
    }

    { // Slide 2
        slide := slideshow_insert_slide(^the_slideshow);
        slide_init(slide, background_color = Color.{ 0.2, 0.1, 0.1 }, item_count = 3);
        
        slide.items[0] = slideshow_make_item(^the_slideshow);
        slide.items[0].kind = Slide_Item.Kind.Text;
        slide.items[0].text.text = "The Second Slide! Duh duh duhhhh";
        slide.items[0].text.y_pos = .2;
        slide.items[0].text.font_name = "bold 72px Arail";

        slide.items[1] = slideshow_make_item(^the_slideshow);
        slide.items[1].kind = Slide_Item.Kind.Text;
        slide.items[1].text.text = "Here is some monospace text.";
        slide.items[1].text.y_pos = .4;
        slide.items[1].text.font_name = "36px monospace";

        slide.items[2] = slideshow_make_item(^the_slideshow);
        slide.items[2].kind = Slide_Item.Kind.Text;
        slide.items[2].text.text = "Here is a block of much longer text that will not wrap correctly, which is annoying but I think the best thing to do is... I don't know yet.";
        slide.items[2].text.y_pos = .7;
        slide.items[2].text.font_name = "36px Calibri";
    }
}

main :: (args: [] cstr) {
    setup_canvas();
    event.init();

    create_dummy_show();

    start_loop :: () -> void #foreign "host" "start_loop" ---
    start_loop();
}
